<!doctype html>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Delaunay Triangulation applied on WebCam stream">
        <meta name="author" content="David Corvoysier / Evan Brooks">
        <title>Triangles</title>






        <style>
            body {
                font-family: "Plantin Std";
                font-weight: lighter;
                color: rgb(91, 91, 151);
                font-size: 40px;
                margin: 100px 200px;
                width: 700px;
                text-indent:-20px;
                padding-top: 600px;
            }
            #quote {
                z-index: 9;
                position: relative;
            }
            progress {
                -webkit-transform: scale(1, 0.3);
            }
            path {
              fill: yellow;
              stroke: #000;
            }
            line {
                pointer-events: none;
                stroke: magenta;
                stroke-width: 0.2px;
            }
            video {
                visibility: hidden;
            }

            svg {
                position: absolute;
                top: 500px;
                -webkit-transform: scale(1.5);
                -webkit-transform-origin: top left;
            }
            #grid {
                visibility: hidden;
            }

            @media print {
                .dg.ac {
                    display: none;
                }
                body {
                    margin: 0.5in;
                    margin-right: 1in;
                    width: auto;
                    font-size: 80px;
                    text-indent:-40px;
                    color: #582e91;
                }
                svg {
                    top: 200px;
                    -webkit-transform: scale(1.5);
                    -webkit-transform-origin: top left;
                }
                #grid {
                    visibility: visible;
                    -webkit-transform: translate3d(150px, 450px, 0) scale(1.2);
                    -webkit-transform-origin: top left;
                }
            }
        </style>
    </head>
















    <body>

        <progress id="faceprogress" max="100" value="50"></progress>

        <div id="quote">
            “It’s constant movement, only it’s bigger, and it has more of a purpose. And it’s trying to figure out what the purpose is that interests me.”  
        </div>          

        <div id="wrapper" style=" width:640px;height:480px;margin: 10px auto; position: absolute; top:100px">
            <!--<img id="webcam" width="640" height="480" src="webcam.png"></img>-->
            <video id="webcam" width="640" height="480"></video>
            <canvas id="grid" width="640" height="480" style="position: absolute;top:0px;left:0px;"></canvas>
            <div id="log" class="alert alert-info"></div>
            <canvas id="canvas" style="visibility: hidden"></canvas>
        </div>

        <script type="text/javascript" src="jsfeat/build/jsfeat-min.js"></script>
        <script type="text/javascript" src="jsfeat/cascades/bbf_face.js"></script>
        <script type="text/javascript" src="dat-gui/build/dat.gui.min.js"></script>
        <script type="text/javascript" src="delaunay/delaunay.js"></script>
        <script type="text/javascript" src="prefixfree/prefixfree.js"></script>
        <script type="text/javascript" src="js/compatibility.js"></script>
        <script type="text/javascript" src="js/profiler.js"></script>
        <script src="http://d3js.org/d3.v3.min.js"></script>
        <script type="text/javascript">

        window.addEventListener("load",function() {





            // Quotes
            // ------

            var quotes = [
                ' “It’s constant movement, only it’s bigger, and it has more of a purpose. And it’s trying to figure out what the purpose is that interests me.” ',
                ' “I like to look at what everyone is doing, find some common thing they’re all assuming, implicitly, but they don’t even realize they’re assuming, and then negate that thing.” ',
                ' “I think there’s some deeper-seated thing ... in understanding life by building something that is lifelike.” ',
                ' “I sort of this joke theory that consciousness was put there by God so he has this quick interface to find out what we’re thinking about.” ',
                ' “In its ultimate form all of this stuff is looking at other ... That feeling that you are in the presence of life that would exist irrelevant of yourself.” ',
                ' “The whole concept of stability is a concept of death. You’re either prey, you’re an an enemy, or ignored.” '
            ];

            var quote = document.getElementById('quote');

            changeQuote();
            function changeQuote() {
                quote.innerHTML = quotes[Math.floor(Math.random() * quotes.length)];
                setTimeout(changeQuote, Math.random()* 200 + 50);
            }







            var video = document.getElementById('webcam');
            var canvas = document.getElementById('canvas');
            var grid = document.getElementById('grid');
            var log = document.getElementById('log');
            try {
                compatibility.getUserMedia({video: true}, function(stream) {
                    try {
                        video.src = compatibility.URL.createObjectURL(stream);
                    } catch (error) {
                        video.src = stream;
                    }
                    setTimeout(function() {
                            video.play();
                            demo_app();
                        
                            compatibility.requestAnimationFrame(tick);
                        }, 500);
                }, function (error) {
                    log.innerHTML = '<h4>Unable to get access to your WebCam.</h4>';
                });
            } catch (error) {
                log.innerHTML = '<h4>Fatal Error.</h4>';
            }
            
            var stat = new profiler();

            var gui,options,ctx,gridCtx;
            var img_u8, face_img_u8, corners, threshold;
            var face_size = [0,0,0,0,0,0];

            var demo_opt = function(){
                this.threshold = 10;
                this.resolution = 0.3;
                this.draw_borders = false;
            }






            function demo_app() {

                options = new demo_opt();
                //gui = new dat.GUI();
                //gui.add(options, 'threshold', 5, 100).step(1);
                var setResolution = function(resolution) {
                    var cwidth = Math.floor(640*resolution);
                    var cheight = Math.floor(480*resolution);
                    img_u8 = new jsfeat.matrix_t(cwidth, cheight, jsfeat.U8_t | jsfeat.C1_t);
                    canvas.width = cwidth;
                    canvas.height = cheight;
                    var style = 'visibility: hidden;transform:scale('+1/resolution+')';                   
                    canvas['style'] = PrefixFree.prefixCSS(style);
                    gridCtx.setTransform(1/resolution,0,0,1/resolution,0,0);
                    corners = [];
                    var i = cwidth*cheight;
                    while(--i >= 0) {
                        corners[i] = new jsfeat.point2d_t(0,0,0,0);
                        corners[i].triangles = [];
                    }
                }

                //var resctl = gui.add(options, 'resolution', 0.1, 1.0).step(0.1);
                //resctl.onFinishChange(function(value){
                //    setResolution(value);
                //});
                //gui.add(options, 'draw_borders');

                stat.add("capture");
                stat.add("grayscale");
                stat.add("fast corners");
                stat.add("triangles");
                stat.add("rendering");
                
                ctx = canvas.getContext('2d');
                gridCtx = grid.getContext('2d');

                setResolution(options.resolution);

                jsfeat.fast_corners.set_threshold(options.threshold);
                jsfeat.bbf.prepare_cascade(jsfeat.bbf.face_cascade);
            }
                        
            function tick() {
                
                //setTimeout(function(){
                    compatibility.requestAnimationFrame(tick);
                //}, 300);
                stat.new_frame();
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    var cwidth = Math.floor(640*options.resolution);
                    var cheight = Math.floor(480*options.resolution);




                    // DRAW FRAME
                    // ----------

                    stat.start("capture");
                    // ctx.globalAlpha = 0.1;
                    ctx.drawImage(video, 0, 0, cwidth, cheight);
                    // ctx.globalAlpha = 1;
                    var imageData = ctx.getImageData(0, 0, cwidth, cheight);
                    stat.stop("capture");



                    // CONVERT TO GRAYSCALE
                    // --------------------
                    stat.start("grayscale");
                    jsfeat.imgproc.grayscale(imageData.data, img_u8.data);
                    //jsfeat.imgproc.box_blur_gray(img_u8.data, img_u8.data, 10, 0);
                    stat.stop("grayscale");
                    // ---------------------
                    var data_u32 = new Uint32Array(imageData.data.buffer);
                    var alpha = (0xff << 24);
                    var i = img_u8.cols*img_u8.rows, pix = 0;
                    while(--i >= 0) {
                        pix = img_u8.data[i];
                        data_u32[i] = alpha | (pix << 16) | (pix << 8) | pix;
                    }
                

                    // DETECT FACES
                    // ------------
                    var pyr = jsfeat.bbf.build_pyramid(img_u8, 24*2, 24*2, 4);
                    var rects = jsfeat.bbf.detect(pyr, jsfeat.bbf.face_cascade);
                    rects = jsfeat.bbf.group_rectangles(rects, 1);



                    // DETECT CORNERS
                    // ------------
                    if(threshold != options.threshold) {
                        threshold = options.threshold|0;
                        jsfeat.fast_corners.set_threshold(threshold);
                    }
                    stat.start("fast corners");
                    var count = jsfeat.fast_corners.detect(img_u8, corners, 5);
                    stat.stop("fast corners");



                    // TRIANGULATE
                    // --------

                    stat.start("triangles");
                    var vertices = [];//{x:0,y:0},{x:cwidth,y:0},{x:cwidth,y:cheight},{x:0,y:cheight}];
                    for(var i=0;i<count;i++) {
                        vertices.push(corners[i]);
                    }
                    var triangles = triangulate(vertices);

                    update_d3(vertices);

                    stat.stop("triangles");




                	var getTriangleColor = function (img,triangle) {
                		var getColor = function (point) {
                			var offset = (point.x+point.y*cwidth)*4;
                			return {    r:img.data[offset],
                						g:img.data[offset+1],
                						b:img.data[offset+2]  };
                		}
                		var midPoint = function (point1,point2) {
                			return {x:(point1.x+point2.x)/2,
                					y:(point1.y+point2.y)/2};
                		}
                		// Pick a point inside the triangle
                		var point1 = midPoint(triangle.a,triangle.b);
                		var point = midPoint(point1,triangle.c);
                		return getColor({x:Math.floor(point.x),y:Math.floor(point.y)});
                	}


                    // RENDER
                    // ------

                    stat.start("rendering");

                    var face_w = draw_faces(gridCtx, rects, cwidth/img_u8.cols, 1);
                    face_detected_update(face_w > 0.2);

                    gridCtx.scale(-1, 1);
                    gridCtx.fillStyle = 'rgb(255,255,255)';
                    gridCtx.fillRect ( 0 , 0 , canvas.width , canvas.height);

                    for(var i=0;i<triangles.length;i++) {
                        var color = triangles[i].color = getTriangleColor(imageData,triangles[i]);

                        var blueness = 255;
                        if (color.b < 125) blueness -= (125 - color.b);

                        gridCtx.fillStyle = 'rgba('+
                            blueness+','+
                            color.g+','+
                            255+','+
                            0.8 + ')';

                        gridCtx.beginPath();

                        gridCtx.moveTo(canvas.width - triangles[i].a.x,triangles[i].a.y);
                        gridCtx.lineTo(canvas.width - triangles[i].b.x,triangles[i].b.y);
                        gridCtx.lineTo(canvas.width - triangles[i].c.x,triangles[i].c.y);



                        gridCtx.closePath();

                        // gridCtx.setLineDash([1,5]);
                        // gridCtx.lineWidth = 0.1;
                        // gridCtx.strokeStyle = 'purple';
                        // gridCtx.stroke();

                        gridCtx.fill();
                        gridCtx.fillStyle = 'rgb(255,255,255)';
                        //gridCtx.fillRect(triangles[i].a.x,triangles[i].a.y, 1, 1);
                    }

                    gridCtx.strokeStyle = 'cyan';

                    gridCtx.scale(1, 1);

                    stat.stop("rendering");

                    // log.innerHTML = stat.log();
                }
            }
            
        },false);




        function draw_faces(ctx, rects, sc, max) {
            var on = rects.length;
            if(on && max) {
                jsfeat.math.qsort(rects, 0, on-1, function(a,b){return (b.confidence<a.confidence);})
            }
            var n = max || on;
            n = Math.min(n, on);
            var r;
            for(var i = 0; i < n; ++i) {
                r = rects[i];
                ctx.strokeRect((r.x*sc)|0,(r.y*sc)|0,(r.width*sc)|0,(r.height*sc)|0);

                return range_to_01(r.width, [24,60]);
            }
        }


        // Facial progress bar
        // ------------
        var progress = document.getElementById("faceprogress");
        var progress_value = 0;
        var progress_max = 100;
        function face_detected_update(there_is_a_face) {
            if (there_is_a_face) progress_value += 0.8;
            else progress_value -= 0.4;

            if (progress_value < 0) progress_value = 0;
            else if (progress_value > progress_max) {
                progress_value = 0;
                window.print();
            } 
            progress.setAttribute("value", progress_value);
        }
        face_detected_update(false);




        // D3 
        // -------

        var sc = 4;

        var width = 1200,
            height = 800;

        var color = d3.scale.category20();

        var force = d3.layout.force()
            .charge(-120)
            .linkDistance(30)
            .size([width, height]);

        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        var d3_geom_voronoi = d3.geom.voronoi().x(function(d) { return d.x; }).y(function(d) { return d.y; })
        var link = svg.selectAll("line");

       var prev_nodes = [];
       var max_ident = 0;
       function update_d3(nodes) {

            // dat = svg.selectAll(".stop")
            //     .data(nodes);

            // dat.enter()
            //     .append("circle")
            //     .attr("r",1)
            //     .attr("class", "stop");

            // dat.transition()
            //     .attr("cx", function(d) { return d.x * sc })
            //     .attr("cy", function(d) { return d.y * sc });

            // dat.exit()
            //     .remove();


            link = link.data(d3_geom_voronoi.links(nodes))
            link.enter().append("line")
            link
                .attr("x1", function(d) { return d.source.x * sc; })
                .attr("y1", function(d) { return d.source.y * sc; })
                .attr("x2", function(d) { return d.target.x * sc; })
                .attr("y2", function(d) { return d.target.y * sc; })

            link.exit().remove()
       }





        // 0-1 to Range and Range to 0-1
        // -----------------------------

        //        (b-a)(x - min)
        // f(x) = --------------  + a
        //           max - min

        function range_to_range (x, inp, out) {
            return ( ( (out[1] - out[0])*(x - inp[0]) ) / (inp[1] - inp[0]) + out[0] );
        }

        function normal_to_range (x, output_range) {
            return range_to_range(x, [0,1], output_range);
        }

        function range_to_01 (x, input_range) {
            return range_to_range(x, input_range, [0,1]);
        }


    </script>


    </body>
</html>
